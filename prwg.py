#!/usr/bin/env python3
import random
from saveAndLoad import SaveAndLoad


class Prwg:
    """
    @author: steampunkv@gmail.com

    This module allows you to analyze text files, generate a JSON file with this data and generate word based
    on this data
    """

    @staticmethod
    def analyse_word_length(file_loc, datafile_name_out='', over_write=False, datafile_name_in='', give_object=False):
        """
        analyze the text file based on word length

        :param file_loc: the path to the text file you want to analyse
        :param datafile_name_out: the path to the JSON file where you want the data to be written
        :param datafile_name_in: the path to a JSON file that you want to load before you analyse anything
        :param over_write: write the data to the JSON FILE where you read the data from
        :param give_object: if you want the saveAndLoad object to be returned
        """
        if over_write:
            datafile_name_out = datafile_name_in

        if datafile_name_out == '' and not give_object:
            raise IOError('No data output given.')

        my_obj = SaveAndLoad(file_loc=datafile_name_in)
        file_in = open(file_loc, "r")
        previous_length = 0

        for line in file_in:
            line = line.split()
            for word in line:
                my_obj.add((previous_length, len(word)))
                previous_length = len(word)

        if datafile_name_out != '':
            my_obj.save_to_file(datafile_name_out)
        if give_object:
            return my_obj

    @staticmethod
    def analyse(file_loc, datafile_name_out='', over_write=False, datafile_name_in='', give_object=False, look_back_amount=1):

        """
        analyse a text file based on what letters follow each other

        :param file_loc: the path to the text file you want to analyse
        :param datafile_name_out: the path to the JSON file where you want the data to be written
        :param datafile_name_in: the path to a JSON file that you want to load before you analyse anything
        :param over_write: write the data to the JSON FILE where you read the data from
        :param give_object: if you want the saveAndLoad object to be returned
        :param look_back_amount: look at the n previous characters
        """
        if over_write:
            datafile_name_out = datafile_name_in

        if datafile_name_out == '' and not give_object:
            raise IOError('No data output given.')

        my_obj = SaveAndLoad(file_loc=datafile_name_in)

        file_in = open(file_loc, "r")

        for line in file_in:
            line = line.split()
            for word in line:

                word = word.lower()
                word = word.center(len(word) + 2)

                i = 0
                while i < len(word) - look_back_amount:
                    a = (word[i:i + look_back_amount], word[i + look_back_amount:i + look_back_amount + 1])
                    my_obj.add(a)
                    i += 1

        if datafile_name_out != '':
            my_obj.save_to_file(datafile_name_out)
        if give_object:
            return my_obj

        # TODO: add option to analyze based on the n preceding characters instead of just one


    @staticmethod
    def __generate_word(file_in, precise_word_length=-1, min_word_length=0):
        previous_char = ' '
        word = ''
        my_obj = SaveAndLoad(file_loc=file_in)

        while True:
            previous_char = random.choices(my_obj.give_keys(previous_char),
                                           weights=my_obj.give_values(previous_char))[0]
            if previous_char != ' ':
                word += previous_char

            # in case the l option is used
            if precise_word_length > 0 and len(word) == precise_word_length:
                break

            # in case the l option isn't used, the word has the minimum length and the previous character is a space
            if previous_char == ' ' and min_word_length <= len(word) and precise_word_length <= 0:
                break
            else:
                continue

            # yes I know these two if statements can be combined but it is more readable this way.

        return word

    @staticmethod
    def generate(file_in, min_word_length=0, precise_word_length=-1, return_string=True,
                 generate_sentence=False, sentence_length=17, sentence_data_file='', starting_word_length=5):
        """
        generate a random word based on the JSON file generated by analyse
        :param file_in: path to the JSON file
        :param min_word_length: the minimum length of the word
        :param precise_word_length: if you want to generate words with a precise length
        :param return_string: if you want the function to return a string instead of printing it, overwrites times and
        random_times
        :param generate_sentence: if you want to generate a sentence, requires the sentence_data_file to be set
        :param sentence_data_file: the path to the word length data file
        :param sentence_length: the disered length of the sentence
        :param starting_word_length: the length of the first word in the sentence
        """

        if generate_sentence:
            next_word_length = starting_word_length

            if sentence_data_file == '':
                raise IOError("sentence_data_file must be valid")
            else:
                sentence = ''
                sentence_obj = SaveAndLoad(sentence_data_file)
                while sentence_length > 0:
                    sentence += Prwg.__generate_word(file_in, precise_word_length=int(next_word_length))
                    sentence += ' '

                    next_word_length = random.choices(sentence_obj.give_keys(str(next_word_length)),
                                                       weights=sentence_obj.give_values(str(next_word_length)))[0]

                    sentence_length -= 1

                if return_string:
                    return sentence
                else:
                    print(sentence)

                exit(0)

        word = Prwg.__generate_word(file_in, min_word_length=min_word_length, precise_word_length=precise_word_length)

        if return_string:
            return word
        else:
            print(word)
